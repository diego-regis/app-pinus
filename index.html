<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PinusSniper V14 (Canvas Engine)</title>
    
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üå≤</text></svg>">

    <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
    <style>
        body { margin: 0; background: #000; color: white; font-family: sans-serif; overflow: hidden; user-select: none; }
        
        /* O Canvas ocupa toda a tela e desenha tudo (Foto, Mira, Pontos) */
        canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }

        /* UI Sobreposta */
        #ui-layer {
            position: absolute; bottom: 0; left: 0; width: 100%;
            background: rgba(10, 10, 10, 0.95); padding: 10px; box-sizing: border-box;
            border-top: 1px solid #333; pointer-events: none; /* Deixa toque passar para o canvas */
            display: flex; flex-direction: column; gap: 10px; padding-bottom: 25px;
        }
        /* Habilita toque apenas nos bot√µes e inputs */
        #ui-layer * { pointer-events: auto; }

        button {
            padding: 14px; border: none; border-radius: 8px; font-weight: bold; font-size: 1rem;
            text-transform: uppercase; cursor: pointer; color: white; width: 100%;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .btn-m { background: #FF9800; }
        .btn-act { background: #D32F2F; height: 60px; font-size: 1.2rem; border: 2px solid white; }
        .btn-save { background: #2E7D32; font-size: 1.1rem; margin-top: 5px; }
        .btn-small { background: #444; font-size: 0.85rem; padding: 10px; }

        .row { display: flex; gap: 10px; }
        input { padding: 10px; width: 100%; text-align: center; background: #333; color: white; border: none; border-radius: 5px; font-size: 1.1rem; }
        label { font-size: 0.75rem; color: #aaa; display: block; text-align: center; margin-bottom: 2px; }

        #stats {
            background: #222; padding: 10px; border-radius: 8px; display: grid;
            grid-template-columns: 1fr 1fr; gap: 10px; text-align: center;
        }
        .stat-box span { font-weight: bold; font-size: 1.2rem; color: #fff; }
        .total-row { grid-column: span 2; border-top: 1px solid #444; margin-top: 5px; padding-top: 8px; font-size: 1.4rem; color: #FFD700; font-weight: bold; }

        #toast {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); border: 2px solid #00ff00; color: #00ff00;
            padding: 20px 40px; border-radius: 10px; display: none; z-index: 200; font-size: 1.5rem; pointer-events: none;
        }

        /* V√≠deo Escondido (apenas para captura) */
        #hidden-video { display: none; }
        
        #reset-cam-btn {
            position: absolute; top: 10px; right: 10px; z-index: 300;
            background: rgba(0,0,0,0.6); border: 1px solid #777; color: #ccc; 
            padding: 5px 10px; border-radius: 20px; font-size: 0.7rem; cursor: pointer; pointer-events: auto;
        }
    </style>
</head>
<body>

    <video id="hidden-video" autoplay playsinline muted></video>
    
    <canvas id="main-canvas"></canvas>

    <button id="reset-cam-btn" onclick="initCamera()">‚ôªÔ∏è Reset C√¢mera</button>
    <div id="toast">SALVO!</div>

    <div id="ui-layer">
        
        <div style="text-align: center; font-size: 0.8rem; color: #777;">
            Pr√≥xima Pilha: <span id="next-id" style="color: #fff; font-weight: bold;">#1</span>
        </div>

        <div class="row">
            <div style="flex:1"><label>Baliza (m)</label><input type="number" id="inp-ref" value="2.00" step="0.1"></div>
            <div style="flex:1"><label>Tora (m)</label><input type="number" id="inp-wood" value="3.00" step="0.1"></div>
        </div>

        <div id="stats">
            <div class="stat-box"><span id="val-h">--</span><br><small style="color:#aaa">ALTURA</small></div>
            <div class="stat-box"><span id="val-l">--</span><br><small style="color:#aaa">COMPR.</small></div>
            <div class="total-row">Vol: <span id="vol-total">0.00</span> st</div>
        </div>

        <div id="menu-main" style="display:flex; flex-direction:column; gap:10px;">
            <div class="row">
                <button class="btn-m" onclick="captureAndStart('HEIGHT')">üìè Altura</button>
                <button class="btn-m" style="background:#1976D2" onclick="captureAndStart('LENGTH')">üìè Comprimento</button>
            </div>
        </div>

        <button id="btn-save" class="btn-save" style="display:none;" onclick="savePile()">üíæ SALVAR PILHA</button>

        <div id="menu-action" class="row" style="display:none;">
            <button class="btn-small" onclick="exitMode()" style="width:70px;">‚ùå</button>
            <button class="btn-act" onclick="addMarker()">üéØ MARCAR</button>
        </div>

        <div class="row" style="margin-top:5px;">
            <button class="btn-small" onclick="exportExcel()">üìÇ Excel (<span id="count">0</span>)</button>
            <button class="btn-small" style="background:#333;" onclick="clearData()">üóëÔ∏è Limpar</button>
        </div>
    </div>

    <script>
        // --- Elementos ---
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('hidden-video');
        
        const menuMain = document.getElementById('menu-main');
        const menuAction = document.getElementById('menu-action');
        const btnSave = document.getElementById('btn-save');

        // --- Estado do App ---
        let state = 'CAMERA'; // 'CAMERA' ou 'EDIT'
        let mode = null; // 'HEIGHT', 'LENGTH'
        
        // --- Estado da "C√¢mera Virtual" (Zoom/Pan) ---
        // A "camera" aqui √© a posi√ß√£o (x,y) da imagem que est√° no centro da tela
        let cam = { x: 0, y: 0, scale: 1 };
        
        // Imagem Capturada
        let capturedImage = new Image();
        let imgLoaded = false;
        
        // Dados da Medi√ß√£o
        let points = [];
        let pxPerMeter = 1;
        let pile = { h:0, l:0 };
        let db = JSON.parse(localStorage.getItem('pinusV14')) || [];
        updateCounter();

        // --- 1. Inicializa√ß√£o ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if(state === 'CAMERA') requestAnimationFrame(loop);
            else drawEdit(); // Redesenha se estiver editando
        }
        window.addEventListener('resize', resize);
        resize();

        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } }
                });
                video.srcObject = stream;
                video.play();
                requestAnimationFrame(loop);
            } catch(e) { alert("Erro C√¢mera: " + e.message); }
        }
        initCamera();

        // --- 2. Loop de Renderiza√ß√£o (Game Engine) ---
        function loop() {
            if(state === 'CAMERA') {
                // Desenha o v√≠deo ao vivo preenchendo a tela (Cover)
                drawCover(video);
                
                // Desenha a mira (Apenas visual, sem pontos)
                drawCrosshair();
                
                requestAnimationFrame(loop);
            }
        }

        function drawEdit() {
            if(!imgLoaded) return;
            
            // Limpa tela
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            
            // 1. Move para o centro da tela
            ctx.translate(canvas.width/2, canvas.height/2);
            // 2. Aplica Zoom
            ctx.scale(cam.scale, cam.scale);
            // 3. Move o "mundo" para a posi√ß√£o da c√¢mera
            ctx.translate(-cam.x, -cam.y);
            
            // 4. Desenha a Imagem
            ctx.drawImage(capturedImage, 0, 0);
            
            // 5. Desenha os Marcadores (que est√£o fixos na imagem)
            points.forEach((p, i) => {
                ctx.beginPath();
                // Cruz do marcador
                ctx.moveTo(p.x - 10, p.y); ctx.lineTo(p.x + 10, p.y);
                ctx.moveTo(p.x, p.y - 10); ctx.lineTo(p.x, p.y + 10);
                ctx.lineWidth = 3 / cam.scale; // Mant√©m linha fina no zoom
                ctx.strokeStyle = (i < 2) ? 'red' : '#00ff00';
                ctx.stroke();
                
                // N√∫mero
                ctx.fillStyle = 'white';
                ctx.font = `bold ${20/cam.scale}px Arial`;
                ctx.fillText(i+1, p.x + (10/cam.scale), p.y - (10/cam.scale));
            });
            
            ctx.restore();
            
            // 6. Desenha a Mira Fixa (Sobre tudo)
            drawCrosshair();
        }

        function drawCover(source) {
            // Simula object-fit: cover
            const vw = canvas.width, vh = canvas.height;
            const sw = source.videoWidth || source.width;
            const sh = source.videoHeight || source.height;
            if(!sw) return;

            const scale = Math.max(vw/sw, vh/sh);
            const w = sw * scale;
            const h = sh * scale;
            const x = (vw - w) / 2;
            const y = (vh - h) / 2;
            
            ctx.drawImage(source, x, y, w, h);
            return { w, h, x, y, scale }; // Retorna m√©tricas para captura
        }

        function drawCrosshair() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            
            ctx.beginPath();
            // Linhas brancas longas
            ctx.moveTo(0, cy); ctx.lineTo(canvas.width, cy);
            ctx.moveTo(cx, 0); ctx.lineTo(cx, canvas.height);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Centro preciso
            ctx.beginPath();
            ctx.arc(cx, cy, 4, 0, Math.PI*2);
            ctx.fillStyle = 'red';
            ctx.fill();
            ctx.stroke();
        }

        // --- 3. L√≥gica de Captura ---
        function captureAndStart(m) {
            mode = m;
            
            // Cria imagem congelada
            const tempCanvas = document.createElement('canvas');
            // Usamos a resolu√ß√£o nativa do v√≠deo para m√°xima qualidade
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            tempCanvas.getContext('2d').drawImage(video, 0, 0);
            
            capturedImage.src = tempCanvas.toDataURL('image/jpeg', 0.9);
            capturedImage.onload = () => {
                imgLoaded = true;
                
                // Configura c√¢mera virtual para focar no centro da imagem inicialmente
                // Mas precisamos ajustar para que a imagem cubra a tela (zoom inicial)
                const metrics = getCoverMetrics(capturedImage.width, capturedImage.height);
                cam.scale = metrics.scale;
                cam.x = capturedImage.width / 2;
                cam.y = capturedImage.height / 2;
                
                state = 'EDIT';
                points = [];
                
                // UI
                menuMain.style.display = 'none';
                btnSave.style.display = 'none';
                menuAction.style.display = 'flex';
                
                drawEdit();
            };
        }
        
        function getCoverMetrics(sw, sh) {
            const vw = canvas.width, vh = canvas.height;
            const scale = Math.max(vw/sw, vh/sh);
            return { scale };
        }

        function exitMode() {
            state = 'CAMERA';
            menuAction.style.display = 'none';
            menuMain.style.display = 'flex';
            updateTotals();
            requestAnimationFrame(loop);
        }

        // --- 4. Marca√ß√£o (O Segredo da Precis√£o) ---
        function addMarker() {
            // O ponto marcado √© EXATAMENTE onde a c√¢mera est√° apontando
            // Como desenhamos a imagem transladada por -cam.x, -cam.y e centralizada...
            // O centro da tela CORRESPONDE a cam.x, cam.y na imagem.
            // Sem contas complexas de convers√£o de tela!
            
            points.push({ x: cam.x, y: cam.y });
            
            if(points.length === 2) {
                const dist = Math.hypot(points[1].x - points[0].x, points[1].y - points[0].y);
                const ref = parseFloat(document.getElementById('inp-ref').value);
                pxPerMeter = dist / ref;
            }
            if(points.length === 4) {
                const dist = Math.hypot(points[3].x - points[2].x, points[3].y - points[2].y);
                const val = dist / pxPerMeter;
                
                if(mode === 'HEIGHT') {
                    pile.h = val;
                    document.getElementById('val-h').innerText = val.toFixed(2);
                } else {
                    pile.l = val;
                    document.getElementById('val-l').innerText = val.toFixed(2);
                }
                exitMode();
            }
            drawEdit();
        }

        // --- 5. Controles de Toque (Pan/Zoom) ---
        let lastDist = 0;
        let lastX = 0, lastY = 0;
        
        canvas.addEventListener('touchstart', e => {
            if(state !== 'EDIT') return;
            e.preventDefault();
            if(e.touches.length === 2) {
                lastDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            } else {
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            }
        }, {passive: false});

        canvas.addEventListener('touchmove', e => {
            if(state !== 'EDIT') return;
            e.preventDefault();
            
            if(e.touches.length === 2) {
                // Zoom
                const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                const delta = dist / lastDist;
                cam.scale *= delta;
                // Limites de zoom
                cam.scale = Math.max(0.1, Math.min(cam.scale, 10));
                lastDist = dist;
            } else {
                // Pan
                // Movemos a c√¢mera na dire√ß√£o OPOSTA ao dedo (arrastar papel)
                // Dividimos pelo scale para mover na velocidade correta da imagem
                const dx = (e.touches[0].clientX - lastX) / cam.scale;
                const dy = (e.touches[0].clientY - lastY) / cam.scale;
                cam.x -= dx;
                cam.y -= dy;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            }
            drawEdit();
        }, {passive: false});

        // --- 6. Dados ---
        function updateTotals() {
            const w = parseFloat(document.getElementById('inp-wood').value);
            const st = (pile.h > 0 && pile.l > 0) ? (pile.h * pile.l * w) : 0;
            document.getElementById('vol-total').innerText = st.toFixed(2);
            btnSave.style.display = st > 0 ? 'block' : 'none';
        }

        function savePile() {
            const nextId = db.length ? Math.max(...db.map(i=>i.id))+1 : 1;
            db.push({
                id: nextId,
                date: new Date().toLocaleTimeString(),
                h: pile.h.toFixed(2), l: pile.l.toFixed(2), w: document.getElementById('inp-wood').value,
                st: document.getElementById('vol-total').innerText
            });
            localStorage.setItem('pinusV14', JSON.stringify(db));
            updateCounter();
            
            pile = {h:0, l:0};
            document.getElementById('val-h').innerText = "--";
            document.getElementById('val-l').innerText = "--";
            updateTotals();
            
            const t = document.getElementById('toast');
            t.style.display='block'; setTimeout(()=>t.style.display='none', 1500);
        }

        function updateCounter() {
            document.getElementById('count').innerText = db.length;
            const next = db.length ? Math.max(...db.map(i=>i.id))+1 : 1;
            document.getElementById('next-id').innerText = "#" + next;
        }
        function clearData() { if(confirm("Apagar tudo?")) { db=[]; localStorage.setItem('pinusV14','[]'); updateCounter(); } }
        function exportExcel() {
            if(!db.length) return alert("Vazio");
            const ws = XLSX.utils.json_to_sheet(db);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Inventario");
            XLSX.writeFile(wb, "Inventario.xlsx");
        }
    </script>
</body>
</html>